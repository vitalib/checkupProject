<b>docker build —tag=java_test .</b>
из /checkupProject/backend/docker-pain/src/test/java_test_container

Сразу оговорюсь, что питон и js не смотрел, не щупал. Разбираемся с джавой, кроме первого вопроса.

<h2>Вопрос 1:</h2>
Представим, что после строчки </br>
java Code > data/result.txt; отсутствует проверка на код завершения. </br>
Чем это черевато? </br>
Если возникает исключение, код завершения 1. </br>
Однако, т.к. мы не проверяем код завершения, и сл. не выкидываем свой код завершения,
то контейнер отработает правильно. (со статусом 0, т.е. как будто поступающий решил правильно) </br>
К чему я веду: здесь мы молодцы и заранее поняли, что место нуждается в доп. обработке. </br>
Однако если поменять код успеха на кастомный - 10 (например), то
поступающий получит баллы 100% только в случае правильного решения, а не по причине нашей забывчивости. </br>
сл. вопрос - оставить 0 или поменять? </br>

<h2>Вопрос 2:</h2>
О чем писал днем (сразу оговорюсь, что решение придумал) </br>
В папке java_data в файле Code.java лежит пожиратель памяти
закомменченный - мой, раскомменченный - нашел на просторах.</br>
Запустим проект (все настроено, только образ надо собрать)
(теперь работает через mvn exec:java) </br>
Контейнер завершится с кодом 6 - т.е. runtime error.
Почему так происходит?</br>
Исключение о нехватке памяти (ООМ) генерирует джава,
а т.к. в коде оно не обрабатывается, то команда </br>
java Code > data/result.txt; завершается со статусом 1,
как и при любом другом исключении. </br>
Вопрос как отличить любое другое исключение от ООМ,
ведь должны быть разные статусы завершения контейнера. </br>
Вариант 1: выводить поток ошибок в файл. Проверять grep'ом на
наличие OutOfMemory. (не оч, как по мне) </br>
Вариант 2: (оставленный)
Меняем докерфайл </br>
java -XX:+ExitOnOutOfMemoryError Code > data/result.txt; </br>
Теперь при ООМ jvm валится с кодом 3. Обработаем: </br>
exitCode=$?; \ </br>
if test $exitCode = 3; then exit 8; fi; \ </br>
if test $exitCode != 0; then exit 6; fi; \ </br>
Как считаешь норм?

<h2>Вопрос 3:</h2>
Беда у разработчиков прошлого была такая: ограничивали объем памяти контейнера,
а jvm все равно жрал сколько хотел</br>
http://matthewkwilliams.com/index.php/2016/03/17/docker-cgroups-memory-constraints-and-java-cautionary-tale/ </br>
как я понял некоторое наследие осталось </br>

Обрати внимание контейнер ограничен 50кк байтов. (это +- 50МБ) </br>
Изменим </br>
java -XX:+ExitOnOutOfMemoryError Code > result.txt;
чтобы почитать вывод в консоль в файле result.txt (он в папке java_data) 
max ~ 24МБ, а где еще 26? </br>
Допустим, они нужны для запуска jvm и все такое
увеличим предел контейнера до 60Мб.
максимум доступно 30мб, а должно, следуя такой логике, 34 </br>
ну короч идея понятна
что память куда-то девается и jvm получить к ней доступ не может. </br>

вернем ограничение контейнер на 50.
я решился на радикальные меры: задал размер хипа для jvm </br>
java -Xms60m -XX:+ExitOnOutOfMemoryError Code > result.txt; </br>
как видно он больше, чем доступно контейнеру. 
запускаем пожирателя. 
в выводе free memory четко видно как он жрет с 60мб и до конца </br>
откуда jvm их берет? (вот под этим я подразумевал наследие)</br>

Вопрос что это такое? что делать с ограничением по памяти?





