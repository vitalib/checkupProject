docker build —tag=java_test .
из /checkupProject/backend/docker-pain/src/test/java_test_container

Сразу оговорюсь, что питон и js не смотрел, не щупал. Разбираемся с джавой, кроме первого вопроса.

Вопрос 1:
Представим, что после строчки
java Code > data/result.txt; отсутствует проверка на код завершения.
Чем это черевато?
Если возникает исключение, код завершения 1.
Однако, т.к. мы не проверяем код возвращения, и сл. не выкидываем свой код завершения,
то контейнер отработает правильно. (со статусом 0, т.е. как будто поступающий решил правильно)
К чему я веду: здесь мы молодцы и заранее поняли, что место нуждается в доп. обработке.
Однако если поменять код успеха на кастомный - 10 (например), то
поступающий получит баллы 100% только в случае правильного решения, а не по причине нашей забывчивости.
сл. вопрос - оставить 0 или поменять?

Вопрос 2:
О чем писал днем (сразу оговорюсь, что решение придумал)
В папке java_data в файле Code.java лежит пожиратель памяти
закомменченный - мой, раскомменченный - нашел на просторах.
Запустим проект (все настроено, только образ надо собрать)
(теперь работает через mvn exec:java)
Контейнер завершится с кодом 6 - т.е. runtime error.
Почему так происходит?
Исключение о нехватке памяти (ООМ) генерирует джава,
а т.к. в коде оно не обрабатывается, то команда
java Code > data/result.txt; завершается со статусом 1,
как и при любом другом исключении.
Вопрос как отличить любое другое исключение от ООМ,
ведь должны быть разные статусы завершения контейнера.
Вариант 1: выводить поток ошибок в файл. Проверять grep`ом на
наличие OutOfMemory. (не оч, как по мне)
Вариант 2: (оставленный)
Меняем докерфайл
java -XX:+ExitOnOutOfMemoryError Code > data/result.txt;
Теперь при ООМ jvm валится с кодом 3. Обработаем:
exitCode=$?; \
if test $exitCode = 3; then exit 8; fi; \
if test $exitCode != 0; then exit 6; fi; \
Как считаешь норм?

Вопрос 3:
Беда у разработчиков прошлого была такая: ограничивали объем памяти контейнера,
а jvm все равно жрал сколько хотел
http://matthewkwilliams.com/index.php/2016/03/17/docker-cgroups-memory-constraints-and-java-cautionary-tale/
как я понял некоторое наследие осталось

Обрати внимание контейнер ограничен 50кк байтов. (это +- 50МБ)
Изменим
java -XX:+ExitOnOutOfMemoryError Code > result.txt;
чтобы почитать вывод в консоль в файле result.txt (он в папке java_data)
max ~ 24МБ, а где еще 26?
Допустим, они нужны для запуска jvm и все такое
увеличим предел контейнера до 60Мб.
максимум доступно 30мб, а должно, следуя такой логике, 34
ну короч идея понятна
что память куда-то девается и jvm получить к ней доступ не может.

вернем ограничение контейнер на 50.
я решился на радикальные меры: задал размер хипа для jvm
java -Xms60m -XX:+ExitOnOutOfMemoryError Code > result.txt;
как видно он больше, чем доступно контейнеру
запускаем пожирателя
в выводе free memory четко видно как он жрет с 60мб и до конца
откуда jvm их берет? (вот под этим я подразумевал наследие)

Вопрос что это такое? что делать с ограничением по памяти?





